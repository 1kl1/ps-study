## 13549
-1, +1을 기준으로 경우의 수가 갈라지기 때문에 tree 탐색 문제라고 생각.

shortest path를 찾는거니까 dfs보다 bfs라고 생각.

bfs -> queue를 사용하는건데, 그정도까지만 기억나고 bfs 구현이 기억이 안나서 애먹음

c++에서는 queue<int> q; 이런식으로 쓰고,

q.front(), q.pop()을 써줘야 앞부분을 pop한것과 동일

q.push()로 새로운 요소 추가

fill_n(checked, 100001, false);

fill_n 사용법

## 1344
경우의 수가 2^18 = 262144로, 수학적으로 확률을 계산해서 풀어도 되겠다는 판단.

overengineering이었지만, factorial 계산을 최적화 해 보고 싶어서 hashmap으로 caching 을 구현해봄

unordered_map<int, double> facts;

unordered_map<int, double>::iterator cached = facts.find(n);

없으면, cached == facts.end();

있으면 cached->first or cached->second로 요소 접근 가능.