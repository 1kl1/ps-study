## 13549
-1, +1을 기준으로 경우의 수가 갈라지기 때문에 tree 탐색 문제라고 생각.

shortest path를 찾는거니까 dfs보다 bfs라고 생각.

bfs -> queue를 사용하는건데, 그정도까지만 기억나고 bfs 구현이 기억이 안나서 애먹음

c++에서는 queue<int> q; 이런식으로 쓰고,

q.front(), q.pop()을 써줘야 앞부분을 pop한것과 동일

q.push()로 새로운 요소 추가

fill_n(checked, 100001, false);

fill_n 사용법

## 1344
경우의 수가 2^18 = 262144로, 수학적으로 확률을 계산해서 풀어도 되겠다는 판단.

overengineering이었지만, factorial 계산을 최적화 해 보고 싶어서 hashmap으로 caching 을 구현해봄

unordered_map<int, double> facts;

unordered_map<int, double>::iterator cached = facts.find(n);

없으면, cached == facts.end();

있으면 cached->first or cached->second로 요소 접근 가능.

## 14269
초기 접근법:
A에 해당하는 길이의 검이 있는지 확인하는 bool array를 이용해서 A 길이의 검 갯수를 셈.

B-C는 C를 오름차순으로 정렬한 뒤, 가능한 한 긴 검을 선택. 이 검으로 처리되는 B-C는 스킵.

그 뒤, 위의 방식을 반복하며 필요한 검의 수를 count.

-> A 길이의 검으로 처리되는 B-C가 있었음(틀림)

-> A로 처리되는 B-C를 제외하는 로직 추가 O(n^2)

-> Timeout

A를 B-Tree로 입력을 받은 뒤에, B-C를 입력받을때마다, A로 처리되지 않는지를 판별하면 O(nlogn)만에 될 것 같다.

-> A로 커버되는 B-C는 판별 됨.

but, 정답이 틀림.

B-C 를 처리하는 과정에서 반례가 있음.(오른차순 정렬 한 후 cover되는 B-C를 끝까지 안봄.)

끝까지 볼 경우 중첩 반복문으로 O(n^2) 시간복잡도.

B-C 범위만큼 +1을 array를 만들어볼까? -> worst case 10^11 계산해야..



c++에서 new는 delete로 메모리 해제함.

make_pair로 pair 만듬.

`[](인자){return~}`로 익명함수 만들 수 있음

## 25547



