## 13549
-1, +1을 기준으로 경우의 수가 갈라지기 때문에 tree 탐색 문제라고 생각.

shortest path를 찾는거니까 dfs보다 bfs라고 생각.

bfs -> queue를 사용하는건데, 그정도까지만 기억나고 bfs 구현이 기억이 안나서 애먹음

c++에서는 queue<int> q; 이런식으로 쓰고,

q.front(), q.pop()을 써줘야 앞부분을 pop한것과 동일

q.push()로 새로운 요소 추가

fill_n(checked, 100001, false);

fill_n 사용법

## 1344
경우의 수가 2^18 = 262144로, 수학적으로 확률을 계산해서 풀어도 되겠다는 판단.

overengineering이었지만, factorial 계산을 최적화 해 보고 싶어서 hashmap으로 caching 을 구현해봄

unordered_map<int, double> facts;

unordered_map<int, double>::iterator cached = facts.find(n);

없으면, cached == facts.end();

있으면 cached->first or cached->second로 요소 접근 가능.

## 14269
초기 접근법:
A에 해당하는 길이의 검이 있는지 확인하는 bool array를 이용해서 A 길이의 검 갯수를 셈.
B-C는 C를 오름차순으로 정렬한 뒤, 가능한 한 긴 검을 선택. 이 검으로 처리되는 B-C는 스킵.
그 뒤, 위의 방식을 반복하며 필요한 검의 수를 count.
-> A 길이의 검으로 처리되는 B-C가 있었음(틀림)
-> A로 처리되는 B-C를 제외하는 로직 추가 O(n^2)
-> Timeout

A를 B-Tree로 입력을 받은 뒤에, B-C를 입력받을때마다, A로 처리되지 않는지를 판별하면 O(nlogn)만에 될 것 같다.

## 25547
