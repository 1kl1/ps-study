## 32358
정렬된 상태를 유지하면서, 내가 원하는 위치로부터 가장 가까운 값을 찾을 수 있는 데이터 구조가 있으면 편하게 풀리겠다.  
-> c++ 에서 set이 red black tree로 구현되니까 set을 사용하자  
-> 2개 이상의 쓰래기가 버려질 수 있으므로 multiset을 사용해보자  
-> 1이면 일단 넣고, 2일 경우에 calc함수로 그때그때의 거리를 계산
-> calc함수는 가장 가까운 쓰래기를 찾아서 거리 계산 후 이동, set에서 뺌.

-> result계산할때 int overflow 생각 못했음. -> 수정

## 14269
검색 결과 그리디는 맞음..  
반례가 뭐가 있는걸까?  
A로 커버되는 검이 하필 자기 자신인 case
2 2 4 <- 이건 검 두자루 필요.
처리 후 풀었음

lower_bount(vector.begin(), vector.end(), 값): 이분탐색


## 18233

n, p가 20 이하.
20C10을 생각하면 184756이 가장 큰 값
다 해볼 수 있겠다
-> 재귀함수로 백트레킹 구현
-> 회원을 선택하는 경우/선택하지 않는 경우로 순회
만약 선택한 회원들의 최소~최대 범위가 맞는다 -> 일단 최소를 다 나눠주고, 앞에서부터 최대까지 채우면서 정답 찾기
